Software As a Service. CS169.1x Engineering Software as a Service.

Teacher : *Armando Foxand and David Patterson*

__Overview!!__


-- Learn Software Engieering Principles by understanding new challenges,opportunities, 
and open problems of SaaS.

-- See how a SaaS project is taken from conception to public deployment.

1. Solve Non-Technical Customer problem.
2. Server Side: Ruby on Rails
3. Client Side: HTML,CSS,AJAX,JavaScript
4. Deploy using cloud computing.

*(GRADING)*
	-- 70% - 5 assignments(homeworks)
	-- 30% - 4 quizzes

*A typical week*


__*Introduction to Software Engineering*__

If SW Engineering so popular, why so many SWE disasters?

Ex. Software bug killed 3 people due to radiation
Mars Climate Orbitor 

*Lessons from  60years of SW development.


__Software as a Service__

-- Traditional SW : binary code installed and runs wholly on client device,which users must upgrade repeatedly
	-- Must work with many versions of hardware, many versions of OS
	-- New versions must go through extensive release cycle to ensure compatibility.

-- An alternative where develop SW that only needs to work on one HW & OS platform?
	-- Quicker release cycle, no user upgrades?

-- SaaS delivers SW & data as service over Internet via thin program(e.g.,browser) running on client device
	-- Search, social networking, video
-- Now also SaaS version of traditional SW E.g.Microsoft office 365, TurboTax Online

-- Instructors think SaaS is revolutionary, the future of virtually all software.

__6 Reasons for SaaS__

1. No install worries about HW capaility, OS
2. No worreis about data loss(data is remote)
3. Easy for grousto interact with same data
4. if data is large or changed frequently, simpler to keep 1 copy at central site
5. 1 copy of SW, single HW/OS environment 
   => No compatibility hassles for developers
   => beta test new features on 1% of users.
6. 1 copy => simplifies upgrades for developers and no user upgrade requests.




## Thing we learn

__Service Oriented Architecture__


SaaS has a related concept known as SOA.

# Software Architecture

1. SOA: SW architecure where all componenets are designed to be services.
2. Apps composed of interoperable services
	- Easy to tailor new version for subset of users.
	- Also easier to recover from mistake in design.


We say it as Software Silo. No API's visible.
3. Contrast to "SW silo" with no internal API's.


*Bezos CEO: Amazon shall use SOA!*

1. "All teams will henceforth expose their data and functionality through service interfaces."
2. "Teams must communicate with each other through those interfaces."
3. "There will be no other form of interprocess communication allowed: no direct linking, nodirect readsof another team's data store, no shared-memory model, no back-doors whatsoever.
The only communication allowed is via service interface calls over the network.".
4. "It doesn't matter what [API protocol] technology you use."
5. "Service interfaces", without exception, must be designed from the ground up to be externalizable. That is to say, the team must plan and design to be able to expose the interface to developers in the outside world. No exceptions."
6. "Anyone who doesn't do this willbe fired."
7. Thank you; have a nice day!"


Example:- 
Non-SOA
* Internal subsystems can share data directly- Review access user profile.
* all subsytems inside single API ("Bookstore")

SOA

* Subsystems independent, as if in separate datacenters - Review Service access User Service API
* Can recombine to make new service("Favourite Books")


__Cloud Computing__


1. SaaS's 3 demands on infrastructure
	a. Communication -- Allow customers to interact with service.
	b. Scalibility -- Fluctuation in demand during + new services to add users rapidly.
	c. Dependability -- Service & Communication available 24x7

2. Services on Clusters
	a. Clusters: Commodity computrs connected by commodity Ethernet switches.
	b. More scalabe than conventional servers
	c. Much cheaerthan conentional server - 20x for equivalent vs.larges servers
	d. Dependability via extensive redundancy.
	e. Few oerators for 1000s servers -- Careful selection of identical HW/SW
					  -- virtual Machine Monitors simlify operation.

3. Warehouse Scale Computers
	a. clusters grew from 1000 servers to 100.000 based on customers demand for SaaS apps.
	b. Economics of scale pushed down cost of largest datacenter by factors 3X to 8X
		-- Purchase, house, operate 100K v. 1k computers
	c. Traditional datacenters utilized 10%-20%
	d. Earn $ offering pay-as-you go use at less than customer's costs for as many computers as customer needs

4. Utility Computing/Public Cloud Computing
	a. Offers computing,storage, communication at pennies per hour.
	b. No premium to scale
		1000 computers @ 1 hours
		= 1 computers @ 1000 hours
	c. Illusion of infinite scalability to cloud user - As many computers as you can afford.
	d. Leading examples: Amazon Web Services, Google App Engine, Microsoft Azure.

5. SuperComputer for hire
	a. Top 500 supercomputer competion in 2012
	b. 532 Eight Extra Large(@ $2.40/hour), 17000 cores = 240 TeraFLOPS
	c. 72nd /500 supercomputer @ ~$1300 per hour
	d. Credit Card => can use 1000s computers
	e. FarmVille on AWS
		- Prior biggest online game 5M users
		- What if startup had to build datacenter?
		- 4 days= 1M, 2 months = 10M; 9 months = 75M


__Beautiful Code Vs. Legacy Code__

1. Programming Athetics
	a. 


__Software Quality Assurance__

Said about product quality, software quality, validation and verification and different Testing techniques like white,black, unit etc..


__Productivity: Conciseness, Synthesis,Reuse,and Tools__

* 50 years of Moore's Law => 2X/1.5 years
	=> HW designer get bigger.
	=> Faster processors and bigger memories
	=> SW desigs get bigger
	=> Had to imporve SW productivity.

* 4 Techniques
	1. Clarity via Conciseness
	2. Synthesis
	3. Reuse

* Syntax: shorter and easier toread
	assert_greater_than_or_equal_to(a,7) s a.should be a>=7
* Raise the level of abstraction:
	- HLL programming languages vs. assemblylang
	- Automatic memory management(Java vs. C)
	- Scripting languages: reflection, metaprogramming

* Software synthesis
	-- BitBit 


=-=======================WEEK1 Half done=========================================

__SW Development Processes: Plan & Documentation__ 

Waterfall model, Spiral Model, Rational Unified Model(RUP)
























































