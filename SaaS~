Software As a Service. CS169.1x Engineering Software as a Service.

Teacher : *Armando Foxand and David Patterson*

__Overview!!__


-- Learn Software Engieering Principles by understanding new challenges,opportunities, 
and open problems of SaaS.

-- See how a SaaS project is taken from conception to public deployment.

1. Solve Non-Technical Customer problem.
2. Server Side: Ruby on Rails
3. Client Side: HTML,CSS,AJAX,JavaScript
4. Deploy using cloud computing.

*(GRADING)*
	-- 70% - 5 assignments(homeworks)
	-- 30% - 4 quizzes

*A typical week*


__*Introduction to Software Engineering*__

If SW Engineering so popular, why so many SWE disasters?

Ex. Software bug killed 3 people due to radiation
Mars Climate Orbitor 

*Lessons from  60years of SW development.


__Software as a Service__

-- Traditional SW : binary code installed and runs wholly on client device,which users must upgrade repeatedly
	-- Must work with many versions of hardware, many versions of OS
	-- New versions must go through extensive release cycle to ensure compatibility.

-- An alternative where develop SW that only needs to work on one HW & OS platform?
	-- Quicker release cycle, no user upgrades?

-- SaaS delivers SW & data as service over Internet via thin program(e.g.,browser) running on client device
	-- Search, social networking, video
-- Now also SaaS version of traditional SW E.g.Microsoft office 365, TurboTax Online

-- Instructors think SaaS is revolutionary, the future of virtually all software.

__6 Reasons for SaaS__

1. No install worries about HW capaility, OS
2. No worreis about data loss(data is remote)
3. Easy for grousto interact with same data
4. if data is large or changed frequently, simpler to keep 1 copy at central site
5. 1 copy of SW, single HW/OS environment 
   => No compatibility hassles for developers
   => beta test new features on 1% of users.
6. 1 copy => simplifies upgrades for developers and no user upgrade requests.




## Thing we learn

__Service Oriented Architecture__


SaaS has a related concept known as SOA.

# Software Architecture

1. SOA: SW architecure where all componenets are designed to be services.
2. Apps composed of interoperable services
	- Easy to tailor new version for subset of users.
	- Also easier to recover from mistake in design.


We say it as Software Silo. No API's visible.
3. Contrast to "SW silo" with no internal API's.


*Bezos CEO: Amazon shall use SOA!*

1. "All teams will henceforth expose their data and functionality through service interfaces."
2. "Teams must communicate with each other through those interfaces."
3. "There will be no other form of interprocess communication allowed: no direct linking, nodirect readsof another team's data store, no shared-memory model, no back-doors whatsoever.
The only communication allowed is via service interface calls over the network.".
4. "It doesn't matter what [API protocol] technology you use."
5. "Service interfaces", without exception, must be designed from the ground up to be externalizable. That is to say, the team must plan and design to be able to expose the interface to developers in the outside world. No exceptions."
6. "Anyone who doesn't do this willbe fired."
7. Thank you; have a nice day!"


Example:- 
Non-SOA
* Internal subsystems can share data directly- Review access user profile.
* all subsytems inside single API ("Bookstore")

SOA

* Subsystems independent, as if in separate datacenters - Review Service access User Service API
* Can recombine to make new service("Favourite Books")


__Cloud Computing__


1. SaaS's 3 demands on infrastructure
	a. Communication -- Allow customers to interact with service.
	b. Scalibility -- Fluctuation in demand during + new services to add users rapidly.
	c. Dependability -- Service & Communication available 24x7

2. Services on Clusters
	a. Clusters: Commodity computrs connected by commodity Ethernet switches.
	b. More scalabe than conventional servers
	c. Much cheaerthan conentional server - 20x for equivalent vs.larges servers
	d. Dependability via extensive redundancy.
	e. Few oerators for 1000s servers -- Careful selection of identical HW/SW
					  -- virtual Machine Monitors simlify operation.

3. Warehouse Scale Computers
	a. clusters grew from 1000 servers to 100.000 based on customers demand for SaaS apps.
	b. Economics of scale pushed down cost of largest datacenter by factors 3X to 8X
		-- Purchase, house, operate 100K v. 1k computers
	c. Traditional datacenters utilized 10%-20%
	d. Earn $ offering pay-as-you go use at less than customer's costs for as many computers as customer needs

4. Utility Computing/Public Cloud Computing
	a. Offers computing,storage, communication at pennies per hour.
	b. No premium to scale
		1000 computers @ 1 hours
		= 1 computers @ 1000 hours
	c. Illusion of infinite scalability to cloud user - As many computers as you can afford.
	d. Leading examples: Amazon Web Services, Google App Engine, Microsoft Azure.

5. SuperComputer for hire
	a. Top 500 supercomputer competion in 2012
	b. 532 Eight Extra Large(@ $2.40/hour), 17000 cores = 240 TeraFLOPS
	c. 72nd /500 supercomputer @ ~$1300 per hour
	d. Credit Card => can use 1000s computers
	e. FarmVille on AWS
		- Prior biggest online game 5M users
		- What if startup had to build datacenter?
		- 4 days= 1M, 2 months = 10M; 9 months = 75M


__Beautiful Code Vs. Legacy Code__

1. Programming Athetics
	a. 


__Software Quality Assurance__

Said about product quality, software quality, validation and verification and different Testing techniques like white,black, unit etc..


__Productivity: Conciseness, Synthesis,Reuse,and Tools__

* 50 years of Moore's Law => 2X/1.5 years
	=> HW designer get bigger.
	=> Faster processors and bigger memories
	=> SW desigs get bigger
	=> Had to imporve SW productivity.

* 4 Techniques
	1. Clarity via Conciseness
	2. Synthesis
	3. Reuse

* Syntax: shorter and easier toread
	assert_greater_than_or_equal_to(a,7) s a.should be a>=7
* Raise the level of abstraction:
	- HLL programming languages vs. assemblylang
	- Automatic memory management(Java vs. C)
	- Scripting languages: reflection, metaprogramming

* Software synthesis
	-- BitBit 


=-=======================WEEK1 Half done=========================================

__SW Development Processes: Plan & Documentation__ 

Waterfall model, Spiral Model, Rational Unified Model(RUP) and Risk Management.

__Development Processes: Agile__

Agile Development is booming lately, giving rise to more working software then a non-working software. In 2001, the idea got immeense attention with people thrasing agile development and even seeing agile as a non software engineering tool. Some labelled it as Hackers apporach which was highly discouraged. 

In 2013, half of the projects are done in agile with distributed systems.

Which statement is TRUE?

THe big different between Agile and P&D is measuring progress against a plan.



__Pitfalls and Summary__


Fallacy : The agile lifecycle is best for software development
	- Good Match for some SW, especially SaaS
	- But not for NASA, code subject and specifications.

Pitfall: Ignoring the cost of software design
	- Since 


Syngery effect.

__Size and Scrum__

Team management is an imporant part of software development. As there is no super programmer era anymore, programmers have to work together.

This was resolved by the idea of scrum organisation. Everyday, everyone of the team members meet at any pre-defined time and answer three questions:

1. What have you done since yesterday?
2. What are you planning to do today?
3. Are there any impediments or stumbling blocks?

* Help individuals by identify what they need.

* Scrum Roles
	-- Team : 2-pizza size team that delivers SW
	-- ScrumMaster: team member who
		- Acts as buffer between the Team and external distractions.
		- Keeps team focused on task at hand.
		- Enforces team rules(coding standard)
		- Removes impediments that prevent team from making progress.

	-- Product Owner : A team member(not the Scrum Master) who represents the voice of the customer and prioritizes user stories.

* Resolving Conflicts.
- Eg. Different view on right technical direction.
1. 1st list all items on which the sides agree
	- vs. starting with list of disagreements.
	- Discover closer together than they realize?
2. Each side articulates the other's arguments, even if don't agree with some
	- Avoids confusion about terms or assumptions, which may be real cause of conflict.

3. Constructive Confrontation(Intel)
	- if you have a strong opinion that a person is proposing the wrong thing technically, you are obligated to bring it up, even to your bosses

4. Disagree and commit(Intel)
	- Once decision made, need to embrace it and move ahead
	- "I disagree, but I am going to helop even if I don't agree."
* Conflict resolutin in personal life.

* Scrum Summary

1. Basically, self-organizing small team with daily standup meetings.
2. Work in "sprints" of 2-4 weeks.
3. Suggest members rotate through roles (especially Product Owner) each iteration.

__Pair Programming__

In Pair Programming, there are two roles: 1. Driver -- who thinks tactically and write the code other is Obeserver who acts as a buffer and thinks strategically. 

--Swap Frequently between driver and observer.

Some features of Pair Programming are:

1. PP quicker when task complexity is low.
2. PP yields higher quality when high
	-- Anecdotally, sometimes more readable code too
3. But more effor than solo programmers? 
4. Also transfers knowledge between pair
	- programming idioms, tool tricks, company processes, latest technologies,...
	- Some teams purposely swap partners per taks
	=> eventually everyone is paired ("promiscuous paring")

The Driver works on tasks at hand, the Observer thinks strategicaly on future tasks.

Everything is an object.

__Ruby Introduction__

Already familiar..


Week2
===========================

### All programming is MetaProgramming

## MetaProgramming and Reflection

1. Reflection let us ask an object questions about itself and have it modify itself.
2. Metaprogramming lets us define new code at runtime.
3. How can these make our code DRYer, more concise, or easier to read?
  

Wrong way to go are as follows:

acct.deposit(100) # deposit $100
acct.deposit(euros_to_dollars(20))
acct.deposit(CurrencyConverter.new(:euros, 20))


Righ way to go:

acct.deposit(100)
acct.deposit(20.euros)

We have open classes in Ruby and can open any class and modify the classes.

Class Numeric
	def euroes
		self*1.292
	end
end

# what happen when I used acct.deposit(1.euro)


# Metaprogramming to the rescue
THere is a drier way to do this by using method missing

class Numeric
	@@currencies = {'yen' => 0.013, 'euro' => 1.292, 'rupee' => 0.019}
	def method_missing(method_id, *args, &block) # capture all args in case have to call super
	singular_currency = method_id.to_s.gsub(/s$/,'')
	if @@currencies.has_key?(singular_currency)
		self * @@currencies[singular_currency]
	else
		super
	end
  end
end


1. attr_accessor is an example of meta-programming.

2. You can ask Ruby objects questions about themseleves at runtime(introspection)
3. You can use this information to generate new code(methods, objects, classes) at runtime (reflection)
4. ....so can have code that writes code(metaprogramming)
5. You can "reopen" any class at any time and add stuff to it.
--..In addition to extending/subclassing it!

Use the simplest way to implement stuff,just we have access to metaprogramming doesn't mean that we have to implement it in meta. A simple function call can do the job.

The last peer-learning question 

## Blocks , Iterators , Functional Idioms(10.23)


1. How can techniques from fucntional programming help us rethink basic programming concepts like iteration?
2. Loops -- but don't think of them that way

['apple','banana','cherry'].each do |string|
	puts string
end

for i in (1..10) do
	puts i
end

1.upto 10 do |num|
	puts num
end

3.times {print "Rah, "}


3. If you're iterating with an index, you're probably doint it worng

a. Iterators let objects manage their own traversal
b. (1..10).each do |x| ... end
c. 1.upto(10) do |x| ... end => range traversal
d. my_array.each do |elt| ... end => array traversal
e. hsh.each_key do |key| ... end
f. hsh.each_pair do |key,val| ... end => hash traversal
g. 10.times {....}
h. 10.times do ... end


4. "Expression orientation"

x= ['apple','cherry','apple','banana']
x.sort 
x.uniq.reverse 
x.reverse!
x.map do |fruit|
	fruit.reverse
end.sort

x.collect { |f| f.include?("e")}

x.any? {|f| f.length > 5}


A real life example

Mechanize

# notice mehtod chaining:

amount = Mechanize.new.
		#note passing of hash argument
		post(url, :username, :password => password).
		# not use of regular expression as hash value
		link_with(:href => /cardValue/i).
		click.
		parser.xpath()"//tr/td[contains(.,'Clipper Cash')"].first.next_sibling.next_sibling.
		content.match(/\$(\d+\.\d+)/)
		html($1)
end



## Mixims and Duck Typing

* Ruby emphasizes 
	"What methods do you respond to?"
over
	"What class do you belong to?"

* How does this encourage productivity through reuse?

* what is "duck typing"?

1. if it responds to the same methods as a duck... it might as well be a duck
2. Similar to Java interfaces but easier to use
3. Example: my_list.sort
		[5,4,3].sort
		["dog","cat","rat"].sort
		[:a,:b,:c].sort
		IO.readlines("my_file").sort

To introduce this concept, we need to study one more concept in ruby called modules, which is not similar to what we understand by modules in other class. 

#### Modules

1. Collection of methods that aren't a class
	- you can't instantiate it
	- Some moduels are namespaces, similar to Python: Math::sin(Math::PI/2.0)
2. Important use of modules: mix its methods into a class:
	Class A ; include Mymodule ; end
	- A.foo wil search A, then MyModule,then method_missing in A & B , then A's ancestor(Super)
	- sort is actually defined in module Enumerable, which is mixed into Array by default.

Modules are collection of behaviour.

Sort is defined in the class Enumerable and not on arrays. Sort wil work on any collection that can enumerate.

If you can return element of an collection, then I can do other things, like select, collect.

#### A Mix-in is a Contract

1. Example: Enumerable assumes target object responds to each
	- ..provides all?, any?, collect, find, include?, inject, map, partition,....
2. Enumerable also provides sort, which requires elements of collection(things returned by each) to respond to <=>(SpaceShip Operator)
3. Comparable assumes that target object respoinds to <=>(other_thing)
	- provides < <= => > == between>? for free.

Class of objects doesn't matter; only methods to which they respond.

Example: sorting a file

* Sorting a file
	- File.open returns an IO Object
	- IO objects respond to each by returning each line as a String.
	- So we can say

File.open('filename.txt').sort
	-relies on IO#each and String#<=>
* Which lines of file being with vowel?

File.open('file').
	select {|s| s=~ /^[aeiou]/i}

Example of Comparable class


Class Accounts
	include Comparable
	def <=>(other)
		self.balance <=> other.balance
	end
end


Why Module? When Class?

1. Moduels reuse behaviors
	- high-level behaviors that could conceptually apply to many classes.
	- Example : Enumerable, Comparable
	- Mechanism : mixin (include Enumerable)
2. Classes reuse implementation
	- subclass reuses/overrides superclass methods
	- Mechanism: inheritance(class A < B)
3. Remarkably often, we will prefer composition over inheritance.>



## Inelegant, this

ArrayList aList;
Iterator it = aList.iterator();
while (it.hasNext()){
	Object element = it.getNext();
	//Do some stuff with element
}



* Goal of the code: do stuff with elemetns of aList
* But iterator logic is all jumbled up with the code.

#### Blocks(anonymous Lamda)

(map '(lamda (x) (+ x 2)) my list)
=> mylist.map {|x| x+2}

(filter '(lamda (x) (even? x)) mylist)
=> mylist.select do |x| ; x.even? ; end

(map
	'(lamda (x) (+ x2))
	(filter '(lambda (x) (even? x)) mylist))

=>mylist.select {|x| x.even?}.map {|x| x+2}


#### Turning iterators inside-out

1. Java:
	- You hadn me each elemet of that collection in turn.
	- I'll do some stuff.
	- Then I'll ask you if there's any more left.
2. Ruby:
	- Here is some code to apply to every element of the collection.
	- You manage the iterator or data structure traversal. Give me each elemet to do stuff to.

An example of yield.

class RandomSequence
	def initialize(limit,num)
		@limit, @num = limit,num
	end
	def each
		@num.times {yield (rand * @limit}.floor}
	end 
end


i = -1
RandomSequence.new(10,4).each do |num|
	i = num if i < num
end

#### Iterators are just one nifty use of yield.

# in File Class

def open(filename)
	...open a file...
end

def close
	...close a file...
end

# in your code

def do_everything
	f = File.open("foo")
	my_custom_stuff(f)
	f.close()
end

Without yield():expose 2
	calls in other library.

Now with yield():expose 1 call in other library

# in some other library
def open(filename)
	...before code..
	yield file_descriptor
	...after code...
end

#in your code

def do_everything
	File.open("foo") do |f|
		my_custom_stuff(f)
	end
end

#### Blocks are Closures

1. A closure is the set of all variables bindings you can "see" at a given point in time.
	-- In Scheme, it's called an environment
2. Blocks are closures: they carry their environment around witht them.
3. Result: blocks can help reuse by seperating what to do from wherae and when to do it.
	-- We'll see various examples in Rails.

>

### Summary

1. Duck typing encourages behavior reuse.
	-- "mix-in" a module and rely on "everything is a method call -- do you respond to this methiod?"

2. Blocks and iterators
	- Blocks are anonymous lambdas that carry their environment around with them.
	- Iterators are an important special use case.

# Overview of BDD + TDD
## Intro to RSpec and Unit Tests

Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition , not smart enough to debug it. -- kerigen 

Testing can never demonstrate the presence of errors in software, only their abscence.
-- Edgar Djiskasta

Testing rocks, debugging sucks.


#### Testing Todayu
* Before
	- developers finish code, some ad-hoc testing
	- "toss over teh wall to Quality Assurance[QA]"
	- QA staff manually poke at software

And then it's shipped, and complains come about hundreds of bugs.

* Today/Agile
	- testing is part of every Agile iteration
	- developers test their own code.
	- testing tools & processes highly automated
	- QA/testing group improves testability and tools.

#### BDD + TDD : The Big Picture

* Behavior-driven design(BDD)
	- develop user stories (the features you wish you had) to describe how app will work.
	- via Cucumber, user stories become acceptance tests and integration tests.


* Test-driven Development (TDD)
	- step definitions for new story, may require new code to be written
	- TDD says: write unit & functional tests for that code first, before the code itself.
	- that is: write tests for the code you wish you had.

##### Cucumber & Rspec

* Cucumber describes behavior via featuers & scenarios (behavior driven desing)
* RSpec tests individual modules that contribute to those behaviors (TDD)

Failing(red)(Cucumber step)(1) ---> Failing(red)RSpec test(2) ---> Passing(Green)RSpec test(go back to 2) (3) ---> Passing(Green) Cucumber step(go back to 1)(4)




## FIRST TDD and getting started with Rspec.

FRIST - an acronym for remebring during test

F(ast) : run (subset) of tests quickly(since you'll be running them all the time)
Independent: no tests depend on others, so can any subset in any order 
Repeatable : run N times, get same result(to help insolate bugs and enable automation)
Self-checking: test can automatically detect if passed (no human checking of output)
Timely: written about the same time as code under test(with TDD, written first!)

RSpec, a Domain-Specific Language(DSL) for testing

* DSL: small programming language that simplifies one tast at expense of generality
	- examples so far: migrations, regexes, SQL

* RSpec tests are called specs or examples
* Run the tests in one file: rspec filename
	- Red failing, Green passing, Yellow pending.


* Much better: running autotest.(running in the background all the time)




#### Week 3

The web as a client-server system; TCP/IP intro -- already known
HTML+CSS -- already known
3 Tier shared- nothing architecure and scaling
MVC
Models, Database and Active Records
Controller, Routers and Restfulness
Template Views and Haml
SaaS architecture

##### 3-Tier shared nothing architecure and scaling
Presentation tier - Apache
logic tier - Rack

__Dynamic content generation__

1. In the Elder Days, most web pages were(collections of) plain old files.
2. But most interesting Web 1.0/e-commerce sites run a program to generate each "page"
3. Originally: templates with embedded code "snippets"
4. Eventaully, code became "tail that wagged the dog" and moved out of the Web Server.

__Sites that are really programs (SaaS)__

1. How do you:

-- Map "URI to correct program and function?
-- Pass arguments?
-- invoke program on server?
-- handle persistent storage?
-- handle cookies?
-- handle errors?
-- package output back to user?

2. Frameworks support these common tasks.


Client(browser) --> Presentation(Web Server) --> Common Gateway Interface(CGI) --> Logic(app) --> persistence.

3. Developer enviroment vs. medium-scale deployment.

Developer ->> WEBRICK --> rack --> rails library --> SQLlite adapter --> file.sqlite3

Scalibility is achieved by NOSQL database.
Large scale curated deployment eg. Heroku

__Scaling and Sharding__

1. Partition data across independent "shards"?
	+ Scales great
	- Bad when operated touch >1 table
	- Example use: user profile
2. Replicated all data everywhere?
	+ Multi-table queries fast
	- Hard to scale : writes must propagate to all copies => temporary inconsistency in data values.
	- Example: Facebook wall posts/"likes"

Summary:

1. Browser requests web resources(URI) using HTTP
	- HTTP is a simple request-reply protocol that relies on TCP/IP.
	- In SaaS, most URI's cause a program to be run, rather than a static file to be fetched.

2. HTML is used to encode content, CSS to style it visually.
3. Cookies allow server to track client
	- Browser automatically passes cookie to server on each request.
	- Server may change cookie on each response.
	- Typical usage: cookie includes a handle to server-side iformation
	- That's why some sites don't work if cookies are completely disabled.

4. Framework make all these abstractions convenient for programmers to use, without sweating the details.

5. and helps map SaaS to 3-tier , shared nothing architecure.




__SaaS architecture__


The big picture

View (HTML & CSS, XML & XPath)
Controller (URI's , HTTP, TCP/IP stack, REST & RESTful routes)
Model (Database and migrations, CRUD)

c. 2008 : "Rails doesn't scale"

1. Scalability is an architectural concern -- not confined to language or framework.
2. The stateless tiers of 3-tier arch do scale
	-- with cloud computing, just worry about constants
3. Traditional relational databases do not scale
4. Various solutions combining relational and non-relational storage("NoSQL" scale much better
	- DataMapper works well with some of them.
5. Intelligent use of caching(later in course) can greatly improve the constant factors.


#### Architecure is about Alernatives

**Patterns we're using				Alternatives**
1. Client-Server				Peer-to-peer
2. Shared-nothing(cloud computing)		Symmetric multiprocessor, shared 							global address space
3. Model-View-Controller			Page controller, Front 							controller,Template view
4. Active Record				Data Mapper
5. RESTful URIs(all sate affecting		Same URI does different things request is explicit)				depending on internal state



As you work on other SaaS apps beyond this course, you should find yourself considering different architectural choices and questioning the choices being made.


Summary : Architecure & Rails

1. Model-View-Controller is a well known architectural pattern for structuring apps.
2. Rails codifies SaaS app structure as MVC
3. Views are Haml w/embedded Ruby code, transformed to HTML when sent to browser
4. Models are stored in tables of a realtional database, accessed using ActiveRecord.
5. Controllers tie views and models together via routes and code in controller methods.

## From Zero to CRUD

-- Directory explanation -- already known.

##### A trip through a Rails app

1. Routes(in routes.rb ) map incoming URL's to controller actions and extract any optional parameters.
	- Route's "wildcard" parameter (eg: id) plus any stuff after "?" in URL, are put into params[] hash accessible in controller actions.

2. Controller actions set instance variables, visible to views
	- Subdirs and filenames of views/ match controller and action names
3. Contoller actions eventaully renders a view.

##### Rails Philosophy

1. Convention over configuration
	- IF naming follows certain conventions, no need for config files.
MoviesControlle#show in movies_controller.rb -> views/movies/show.html.haml

2. Don't Repeat Yourself(DRY)
	- mechanisms to extact common functionality.
3. Both rely havily on ruby features:
	-introspection and metaprogramming
	- blocks(closures)
	- modules(mix-ins)


## When things go wrong. Debugging

##### Debugging SaaS can be tricky.

1. "Terminal" (STDERR) not always available.
2. Erros early in flow may manifest much later
URI -> route -> contrtoller -> model -> view -> render
3. Error may be hard to localize/reproduce. 

##### RASP

1. Debugging is a fact of life.
2. Read the error message. Really read it.
3. Ask a colleague an informed question.
4. Search using Stackoverflow, a search engine, etc.
	- Especially for errors involving specific versions of gems, OS, etc.
5. Post on StackOverflow 

##### Reading Ruby error messages

1. The backtrace shows you the call stack(where you came from) at the stop point.
2. A very common message
	undefined method 'foo' for nil:NilClass
3. Often, it means an assignment silently failed and you didn't error check:

@m = Movie.find_by_id(id) #could be nil
@m.title # will fail: 'undefined method'

###### Instrumentation(a/k/a "printing the values of things")

1. In views:
	= debug(@movie)
	= @movie.inspect
2. In the log, usually from controller method:
	logger.debug(@movie.inspect)

3. Don't just use puts or printf! It has nowhere to go when in production.

##### Search:Use the Internet to answer questions

1. Google it
	- "how do I format a _date_ in _ruby_?
	- "how do I add rails routes beyond CRUD/
2. Check the documentation
	- api.rubyonrails.org complete 
3. Stackoverflow

#### Use rails console
1. like irb, but load Rails +your app code
2. But context is still not quite right for "peeking into" controller and views.


## Models: ActiveRecord Basics

ActiveRecord is a Design pattern. How to connect inmemory objects and how they are stored in the database.

How can language features simplify design and implementation of design patterns?
In this case, Active Record, which "bridges the gap" between in -memory Ruby objects and their stored representation in a database.

##### CRUD IN SQL

1. Stuctured Query language (SQL) is the query language used by RDBMS
2. Rails generates SQL statement at runtime, basd on your ruby code.
3. 4 basic operations on a table row:
Create, Read, Update attributes, Delete

INSERT INTO users (atr1, atr2 ,atr3) values (at1 = val1, atr2 =val2, ....)
select * from usrs where ()
update users set email = "" where username = ???
delete from users where id =1

Subcalssing from ActiveRecord::Base
- connects a model to the database.
- provides CRUD operation on the model.

Database table name derived from model's name : Movie -> movies.
Database table column names are getters and setters for model attributes.
Observe: the getters and setters do not simply modify instance variables!


class Movie < ActiveRecord::Base
end

movie = Movie.new
movie.title = "The help"
movie.rating = "PG-13"

movie = Movie.new do |n|
	n.title = "The help"
	n.rating = "PG-13"
end

movie.save

##### Creating: new =/ save

1. Must call save or save! on an AR model instance to actually save changes to DB.
	- '!' version throws exception if operation fails
	- create just combines new and save.
2. Once created, object acquires a primary key (id column in every AR model table)
	- if x.id is nil or x.new_record? is true, x has never been saved.
	- These behaviors inherited from ActiveRecrod::Base -- not true of Ruby objects in general.



'>
## Database & Migration 

##### Your customer data is golden!

1. How do we avoid messing it up when experimenting/developing new features?
2. How do we track and manage schema change?
3. ...the answer to both is automation!

##### Multiple environments, multiple databases
1. Rails solution: development, production and test environment each have own DB
	- Different DB types apporiate for each!
2. How to make changes to DB, since will have to repeat changes on production DB?
3. Rails solution: migration -- script describing changes, portable across DB types.

##### Migration Advantages

1. Can identify each migration, and know which one(s) applied and when
	- Many migrations can created to be reversible
2. Can manage with version control
3. Automated == reliably repeatable

4. Theme : don't do it- automate it.
 -- specify what to dom create tools to automate.

> rails generate migration CreateMovies

class CreateMovies < ActiveRecord::Migration
def up
	create_table 'movies' do |t|
		t.string 'title'
		t.string 'rating'
		t.text 'description'
		t.datetime 'release_date'
		# Add fileds that let Rails automaticall keep track
		# of when movies are added or modified:
		t.timestamps
	end
end

def down
	drop_table "movies" # deletes the whole table and all its data!
end
end
>
 
Note , this creates the migration. We haven't applied it.
Apply migration to development.


> rake db:migrate

Apply migration to production:
heroku rake db:migrate

Applying migration also records DB itself which migrations have been applied.


##### Rails Cookery #1
1. Augmenting app functionality == 
	adding models, views, controller actions

To add a new model to a Rails app:
	- (or change/add attributes of an existing model)

1. Create a migration describing the changes:
	rails generate migration(gives you boilerplate)
2. Apply the migration: rake db:migrate
3. if new model, create model file
	app/models/model.rb
4. Update test DB schema : rake db:test:prepare

## Models: Finding, Updating, Deleting 

Read: fidning things in DB

1. Class method where selects objects based on attributes.

Movie.where("rating='PG'")
Movie.where('release_date <:cutoff and rating = :rating', :rating => 'PG', :cutoff => 1.year.ago)
Movie.where("rating=#{rating}") #BAD IDEA!

2. Can be chained togehter efficiently

kiddie = Movie.where("rating='G'")

old_kids_films = kiddie.where("release_date <?" , 30.years.ago)


Only when we used the query or do work on them then only they are executed.
It' is basically an activerelation engine.

3. find by id:
	Movie.find(3) #exception if not found
	Movie.find_by_id(3)

4. Dynamic attribute-based finders:
	Movie.find_all_by_rating('PG')
	Movie.find_by_rating('PG')
	Movie.find_by_rating!('PG')

5. Updating : 2 ways

- Let m = Movie.find_by_title('The Help')
- Modify attributes, then save object m.release_date = '2011-Aug-10'
										m.save!
-> Update attributes on existing object 
m.update_attributes
	:release_dates => '2011-Aug-10'

- Transactional: either all attributes are updated, or none are

























