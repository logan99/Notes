Software As a Service. CS169.1x Engineering Software as a Service.

Teacher : *Armando Foxand and David Patterson*

__Overview!!__


-- Learn Software Engieering Principles by understanding new challenges,opportunities, 
and open problems of SaaS.

-- See how a SaaS project is taken from conception to public deployment.

1. Solve Non-Technical Customer problem.
2. Server Side: Ruby on Rails
3. Client Side: HTML,CSS,AJAX,JavaScript
4. Deploy using cloud computing.

*(GRADING)*
	-- 70% - 5 assignments(homeworks)
	-- 30% - 4 quizzes

*A typical week*


__*Introduction to Software Engineering*__

If SW Engineering so popular, why so many SWE disasters?

Ex. Software bug killed 3 people due to radiation
Mars Climate Orbitor 

*Lessons from  60years of SW development.


__Software as a Service__

-- Traditional SW : binary code installed and runs wholly on client device,which users must upgrade repeatedly
	-- Must work with many versions of hardware, many versions of OS
	-- New versions must go through extensive release cycle to ensure compatibility.

-- An alternative where develop SW that only needs to work on one HW & OS platform?
	-- Quicker release cycle, no user upgrades?

-- SaaS delivers SW & data as service over Internet via thin program(e.g.,browser) running on client device
	-- Search, social networking, video
-- Now also SaaS version of traditional SW E.g.Microsoft office 365, TurboTax Online

-- Instructors think SaaS is revolutionary, the future of virtually all software.

__6 Reasons for SaaS__

1. No install worries about HW capaility, OS
2. No worreis about data loss(data is remote)
3. Easy for grousto interact with same data
4. if data is large or changed frequently, simpler to keep 1 copy at central site
5. 1 copy of SW, single HW/OS environment 
   => No compatibility hassles for developers
   => beta test new features on 1% of users.
6. 1 copy => simplifies upgrades for developers and no user upgrade requests.




## Thing we learn

__Service Oriented Architecture__


SaaS has a related concept known as SOA.

# Software Architecture

1. SOA: SW architecure where all componenets are designed to be services.
2. Apps composed of interoperable services
	- Easy to tailor new version for subset of users.
	- Also easier to recover from mistake in design.


We say it as Software Silo. No API's visible.
3. Contrast to "SW silo" with no internal API's.


*Bezos CEO: Amazon shall use SOA!*

1. "All teams will henceforth expose their data and functionality through service interfaces."
2. "Teams must communicate with each other through those interfaces."
3. "There will be no other form of interprocess communication allowed: no direct linking, nodirect readsof another team's data store, no shared-memory model, no back-doors whatsoever.
The only communication allowed is via service interface calls over the network.".
4. "It doesn't matter what [API protocol] technology you use."
5. "Service interfaces", without exception, must be designed from the ground up to be externalizable. That is to say, the team must plan and design to be able to expose the interface to developers in the outside world. No exceptions."
6. "Anyone who doesn't do this willbe fired."
7. Thank you; have a nice day!"


Example:- 
Non-SOA
* Internal subsystems can share data directly- Review access user profile.
* all subsytems inside single API ("Bookstore")

SOA

* Subsystems independent, as if in separate datacenters - Review Service access User Service API
* Can recombine to make new service("Favourite Books")


__Cloud Computing__


1. SaaS's 3 demands on infrastructure
	a. Communication -- Allow customers to interact with service.
	b. Scalibility -- Fluctuation in demand during + new services to add users rapidly.
	c. Dependability -- Service & Communication available 24x7

2. Services on Clusters
	a. Clusters: Commodity computrs connected by commodity Ethernet switches.
	b. More scalabe than conventional servers
	c. Much cheaerthan conentional server - 20x for equivalent vs.larges servers
	d. Dependability via extensive redundancy.
	e. Few oerators for 1000s servers -- Careful selection of identical HW/SW
					  -- virtual Machine Monitors simlify operation.

3. Warehouse Scale Computers
	a. clusters grew from 1000 servers to 100.000 based on customers demand for SaaS apps.
	b. Economics of scale pushed down cost of largest datacenter by factors 3X to 8X
		-- Purchase, house, operate 100K v. 1k computers
	c. Traditional datacenters utilized 10%-20%
	d. Earn $ offering pay-as-you go use at less than customer's costs for as many computers as customer needs

4. Utility Computing/Public Cloud Computing
	a. Offers computing,storage, communication at pennies per hour.
	b. No premium to scale
		1000 computers @ 1 hours
		= 1 computers @ 1000 hours
	c. Illusion of infinite scalability to cloud user - As many computers as you can afford.
	d. Leading examples: Amazon Web Services, Google App Engine, Microsoft Azure.

5. SuperComputer for hire
	a. Top 500 supercomputer competion in 2012
	b. 532 Eight Extra Large(@ $2.40/hour), 17000 cores = 240 TeraFLOPS
	c. 72nd /500 supercomputer @ ~$1300 per hour
	d. Credit Card => can use 1000s computers
	e. FarmVille on AWS
		- Prior biggest online game 5M users
		- What if startup had to build datacenter?
		- 4 days= 1M, 2 months = 10M; 9 months = 75M


__Beautiful Code Vs. Legacy Code__

1. Programming Athetics
	a. 


__Software Quality Assurance__

Said about product quality, software quality, validation and verification and different Testing techniques like white,black, unit etc..


__Productivity: Conciseness, Synthesis,Reuse,and Tools__

* 50 years of Moore's Law => 2X/1.5 years
	=> HW designer get bigger.
	=> Faster processors and bigger memories
	=> SW desigs get bigger
	=> Had to imporve SW productivity.

* 4 Techniques
	1. Clarity via Conciseness
	2. Synthesis
	3. Reuse

* Syntax: shorter and easier toread
	assert_greater_than_or_equal_to(a,7) s a.should be a>=7
* Raise the level of abstraction:
	- HLL programming languages vs. assemblylang
	- Automatic memory management(Java vs. C)
	- Scripting languages: reflection, metaprogramming

* Software synthesis
	-- BitBit 


=-=======================WEEK1 Half done=========================================

__SW Development Processes: Plan & Documentation__ 

Waterfall model, Spiral Model, Rational Unified Model(RUP) and Risk Management.

__Development Processes: Agile__

Agile Development is booming lately, giving rise to more working software then a non-working software. In 2001, the idea got immeense attention with people thrasing agile development and even seeing agile as a non software engineering tool. Some labelled it as Hackers apporach which was highly discouraged. 

In 2013, half of the projects are done in agile with distributed systems.

Which statement is TRUE?

THe big different between Agile and P&D is measuring progress against a plan.



__Pitfalls and Summary__


Fallacy : The agile lifecycle is best for software development
	- Good Match for some SW, especially SaaS
	- But not for NASA, code subject and specifications.

Pitfall: Ignoring the cost of software design
	- Since 


Syngery effect.

__Size and Scrum__

Team management is an imporant part of software development. As there is no super programmer era anymore, programmers have to work together.

This was resolved by the idea of scrum organisation. Everyday, everyone of the team members meet at any pre-defined time and answer three questions:

1. What have you done since yesterday?
2. What are you planning to do today?
3. Are there any impediments or stumbling blocks?

* Help individuals by identify what they need.

* Scrum Roles
	-- Team : 2-pizza size team that delivers SW
	-- ScrumMaster: team member who
		- Acts as buffer between the Team and external distractions.
		- Keeps team focused on task at hand.
		- Enforces team rules(coding standard)
		- Removes impediments that prevent team from making progress.

	-- Product Owner : A team member(not the Scrum Master) who represents the voice of the customer and prioritizes user stories.

* Resolving Conflicts.
- Eg. Different view on right technical direction.
1. 1st list all items on which the sides agree
	- vs. starting with list of disagreements.
	- Discover closer together than they realize?
2. Each side articulates the other's arguments, even if don't agree with some
	- Avoids confusion about terms or assumptions, which may be real cause of conflict.

3. Constructive Confrontation(Intel)
	- if you have a strong opinion that a person is proposing the wrong thing technically, you are obligated to bring it up, even to your bosses

4. Disagree and commit(Intel)
	- Once decision made, need to embrace it and move ahead
	- "I disagree, but I am going to helop even if I don't agree."
* Conflict resolutin in personal life.

* Scrum Summary

1. Basically, self-organizing small team with daily standup meetings.
2. Work in "sprints" of 2-4 weeks.
3. Suggest members rotate through roles (especially Product Owner) each iteration.

__Pair Programming__

In Pair Programming, there are two roles: 1. Driver -- who thinks tactically and write the code other is Obeserver who acts as a buffer and thinks strategically. 

--Swap Frequently between driver and observer.

Some features of Pair Programming are:

1. PP quicker when task complexity is low.
2. PP yields higher quality when high
	-- Anecdotally, sometimes more readable code too
3. But more effor than solo programmers? 
4. Also transfers knowledge between pair
	- programming idioms, tool tricks, company processes, latest technologies,...
	- Some teams purposely swap partners per taks
	=> eventually everyone is paired ("promiscuous paring")

The Driver works on tasks at hand, the Observer thinks strategicaly on future tasks.

Everything is an object.

__Ruby Introduction__

Already familiar..


Week2
===========================

### All programming is MetaProgramming

## MetaProgramming and Reflection

1. Reflection let us ask an object questions about itself and have it modify itself.
2. Metaprogramming lets us define new code at runtime.
3. How can these make our code DRYer, more concise, or easier to read?
  

Wrong way to go are as follows:

acct.deposit(100) # deposit $100
acct.deposit(euros_to_dollars(20))
acct.deposit(CurrencyConverter.new(:euros, 20))


Righ way to go:

acct.deposit(100)
acct.deposit(20.euros)

We have open classes in Ruby and can open any class and modify the classes.

Class Numeric
	def euroes
		self*1.292
	end
end

# what happen when I used acct.deposit(1.euro)


# Metaprogramming to the rescue
THere is a drier way to do this by using method missing

class Numeric
	@@currencies = {'yen' => 0.013, 'euro' => 1.292, 'rupee' => 0.019}
	def method_missing(method_id, *args, &block) # capture all args in case have to call super
	singular_currency = method_id.to_s.gsub(/s$/,'')
	if @@currencies.has_key?(singular_currency)
		self * @@currencies[singular_currency]
	else
		super
	end
  end
end


1. attr_accessor is an example of meta-programming.

2. You can ask Ruby objects questions about themseleves at runtime(introspection)
3. You can use this information to generate new code(methods, objects, classes) at runtime (reflection)
4. ....so can have code that writes code(metaprogramming)
5. You can "reopen" any class at any time and add stuff to it.
--..In addition to extending/subclassing it!

Use the simplest way to implement stuff,just we have access to metaprogramming doesn't mean that we have to implement it in meta. A simple function call can do the job.

The last peer-learning question 

## Blocks , Iterators , Functional Idioms(10.23)


1. How can techniques from fucntional programming help us rethink basic programming concepts like iteration?
2. Loops -- but don't think of them that way

['apple','banana','cherry'].each do |string|
	puts string
end

for i in (1..10) do
	puts i
end

1.upto 10 do |num|
	puts num
end

3.times {print "Rah, "}


3. If you're iterating with an index, you're probably doint it worng

a. Iterators let objects manage their own traversal
b. (1..10).each do |x| ... end
c. 1.upto(10) do |x| ... end => range traversal
d. my_array.each do |elt| ... end => array traversal
e. hsh.each_key do |key| ... end
f. hsh.each_pair do |key,val| ... end => hash traversal
g. 10.times {....}
h. 10.times do ... end


4. "Expression orientation"

x= ['apple','cherry','apple','banana']
x.sort 
x.uniq.reverse 
x.reverse!
x.map do |fruit|
	fruit.reverse
end.sort

x.collect { |f| f.include?("e")}

x.any? {|f| f.length > 5}


A real life example

Mechanize

# notice mehtod chaining:

amount = Mechanize.new.
		#note passing of hash argument
		post(url, :username, :password => password).
		# not use of regular expression as hash value
		link_with(:href => /cardValue/i).
		click.
		parser.xpath()"//tr/td[contains(.,'Clipper Cash')"].first.next_sibling.next_sibling.
		content.match(/\$(\d+\.\d+)/)
		html($1)
end



## Mixims and Duck Typing

* Ruby emphasizes 
	"What methods do you respond to?"
over
	"What class do you belong to?"

* How does this encourage productivity through reuse?

* what is "duck typing"?

1. if it responds to the same methods as a duck... it might as well be a duck
2. Similar to Java interfaces but easier to use
3. Example: my_list.sort
		[5,4,3].sort
		["dog","cat","rat"].sort
		[:a,:b,:c].sort
		IO.readlines("my_file").sort

To introduce this concept, we need to study one more concept in ruby called modules, which is not similar to what we understand by modules in other class. 

#### Modules

1. Collection of methods that aren't a class
	- you can't instantiate it
	- Some moduels are namespaces, similar to Python: Math::sin(Math::PI/2.0)
2. Important use of modules: mix its methods into a class:
	Class A ; include Mymodule ; end
	- A.foo wil search A, then MyModule,then method_missing in A & B , then A's ancestor(Super)
	- sort is actually defined in module Enumerable, which is mixed into Array by default.

Modules are collection of behaviour.

Sort is defined in the class Enumerable and not on arrays. Sort wil work on any collection that can enumerate.

If you can return element of an collection, then I can do other things, like select, collect.

#### A Mix-in is a Contract

1. Example: Enumerable assumes target object responds to each
	- ..provides all?, any?, collect, find, include?, inject, map, partition,....
2. Enumerable also provides sort, which requires elements of collection(things returned by each) to respond to <=>(SpaceShip Operator)
3. Comparable assumes that target object respoinds to <=>(other_thing)
	- provides < <= => > == between>? for free.

Class of objects doesn't matter; only methods to which they respond.

Example: sorting a file

* Sorting a file
	- File.open returns an IO Object
	- IO objects respond to each by returning each line as a String.
	- So we can say

File.open('filename.txt').sort
	-relies on IO#each and String#<=>
* Which lines of file being with vowel?

File.open('file').
	select {|s| s=~ /^[aeiou]/i}

Example of Comparable class


Class Accounts
	include Comparable
	def <=>(other)
		self.balance <=> other.balance
	end
end


Why Module? When Class?

1. Moduels reuse behaviors
	- high-level behaviors that could conceptually apply to many classes.
	- Example : Enumerable, Comparable
	- Mechanism : mixin (include Enumerable)
2. Classes reuse implementation
	- subclass reuses/overrides superclass methods
	- Mechanism: inheritance(class A < B)
3. Remarkably often, we will prefer composition over inheritance.>



## Inelegant, this

ArrayList aList;
Iterator it = aList.iterator();
while (it.hasNext()){
	Object element = it.getNext();
	//Do some stuff with element
}



* Goal of the code: do stuff with elemetns of aList
* But iterator logic is all jumbled up with the code.

#### Blocks(anonymous Lamda)

(map '(lamda (x) (+ x 2)) my list)
=> mylist.map {|x| x+2}

(filter '(lamda (x) (even? x)) mylist)
=> mylist.select do |x| ; x.even? ; end

(map
	'(lamda (x) (+ x2))
	(filter '(lambda (x) (even? x)) mylist))

=>mylist.select {|x| x.even?}.map {|x| x+2}


#### Turning iterators inside-out

1. Java:
	- You hadn me each elemet of that collection in turn.
	- I'll do some stuff.
	- Then I'll ask you if there's any more left.
2. Ruby:
	- Here is some code to apply to every element of the collection.
	- You manage the iterator or data structure traversal. Give me each elemet to do stuff to.

An example of yield.

class RandomSequence
	def initialize(limit,num)
		@limit, @num = limit,num
	end
	def each
		@num.times {yield (rand * @limit}.floor}
	end 
end


i = -1
RandomSequence.new(10,4).each do |num|
	i = num if i < num
end

#### Iterators are just one nifty use of yield.

# in File Class

def open(filename)
	...open a file...
end

def close
	...close a file...
end

# in your code

def do_everything
	f = File.open("foo")
	my_custom_stuff(f)
	f.close()
end

Without yield():expose 2
	calls in other library.

Now with yield():expose 1 call in other library

# in some other library
def open(filename)
	...before code..
	yield file_descriptor
	...after code...
end

#in your code

def do_everything
	File.open("foo") do |f|
		my_custom_stuff(f)
	end
end

#### Blocks are Closures

1. A closure is the set of all variables bindings you can "see" at a given point in time.
	-- In Scheme, it's called an environment
2. Blocks are closures: they carry their environment around witht them.
3. Result: blocks can help reuse by seperating what to do from wherae and when to do it.
	-- We'll see various examples in Rails.

>

### Summary

1. Duck typing encourages behavior reuse.
	-- "mix-in" a module and rely on "everything is a method call -- do you respond to this methiod?"

2. Blocks and iterators
	- Blocks are anonymous lambdas that carry their environment around with them.
	- Iterators are an important special use case.

# Overview of BDD + TDD
## Intro to RSpec and Unit Tests

Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition , not smart enough to debug it. -- kerigen 

Testing can never demonstrate the presence of errors in software, only their abscence.
-- Edgar Djiskasta

Testing rocks, debugging sucks.


#### Testing Todayu
* Before
	- developers finish code, some ad-hoc testing
	- "toss over teh wall to Quality Assurance[QA]"
	- QA staff manually poke at software

And then it's shipped, and complains come about hundreds of bugs.

* Today/Agile
	- testing is part of every Agile iteration
	- developers test their own code.
	- testing tools & processes highly automated
	- QA/testing group improves testability and tools.

#### BDD + TDD : The Big Picture

* Behavior-driven design(BDD)
	- develop user stories (the features you wish you had) to describe how app will work.
	- via Cucumber, user stories become acceptance tests and integration tests.


* Test-driven Development (TDD)
	- step definitions for new story, may require new code to be written
	- TDD says: write unit & functional tests for that code first, before the code itself.
	- that is: write tests for the code you wish you had.

##### Cucumber & Rspec

* Cucumber describes behavior via featuers & scenarios (behavior driven desing)
* RSpec tests individual modules that contribute to those behaviors (TDD)

Failing(red)(Cucumber step)(1) ---> Failing(red)RSpec test(2) ---> Passing(Green)RSpec test(go back to 2) (3) ---> Passing(Green) Cucumber step(go back to 1)(4)




## FIRST TDD and getting started with Rspec.

FRIST - an acronym for remebring during test

F(ast) : run (subset) of tests quickly(since you'll be running them all the time)
Independent: no tests depend on others, so can any subset in any order 
Repeatable : run N times, get same result(to help insolate bugs and enable automation)
Self-checking: test can automatically detect if passed (no human checking of output)
Timely: written about the same time as code under test(with TDD, written first!)

RSpec, a Domain-Specific Language(DSL) for testing

* DSL: small programming language that simplifies one tast at expense of generality
	- examples so far: migrations, regexes, SQL

* RSpec tests are called specs or examples
* Run the tests in one file: rspec filename
	- Red failing, Green passing, Yellow pending.


* Much better: running autotest.(running in the background all the time)




#### Week 3

The web as a client-server system; TCP/IP intro -- already known
HTML+CSS -- already known
3 Tier shared- nothing architecure and scaling
MVC
Models, Database and Active Records
Controller, Routers and Restfulness
Template Views and Haml
SaaS architecture

##### 3-Tier shared nothing architecure and scaling
Presentation tier - Apache
logic tier - Rack

__Dynamic content generation__

1. In the Elder Days, most web pages were(collections of) plain old files.
2. But most interesting Web 1.0/e-commerce sites run a program to generate each "page"
3. Originally: templates with embedded code "snippets"
4. Eventaully, code became "tail that wagged the dog" and moved out of the Web Server.

__Sites that are really programs (SaaS)__

1. How do you:

-- Map "URI to correct program and function?
-- Pass arguments?
-- invoke program on server?
-- handle persistent storage?
-- handle cookies?
-- handle errors?
-- package output back to user?

2. Frameworks support these common tasks.


Client(browser) --> Presentation(Web Server) --> Common Gateway Interface(CGI) --> Logic(app) --> persistence.

3. Developer enviroment vs. medium-scale deployment.

Developer ->> WEBRICK --> rack --> rails library --> SQLlite adapter --> file.sqlite3

Scalibility is achieved by NOSQL database.
Large scale curated deployment eg. Heroku

__Scaling and Sharding__

1. Partition data across independent "shards"?
	+ Scales great
	- Bad when operated touch >1 table
	- Example use: user profile
2. Replicated all data everywhere?
	+ Multi-table queries fast
	- Hard to scale : writes must propagate to all copies => temporary inconsistency in data values.
	- Example: Facebook wall posts/"likes"

Summary:

1. Browser requests web resources(URI) using HTTP
	- HTTP is a simple request-reply protocol that relies on TCP/IP.
	- In SaaS, most URI's cause a program to be run, rather than a static file to be fetched.

2. HTML is used to encode content, CSS to style it visually.
3. Cookies allow server to track client
	- Browser automatically passes cookie to server on each request.
	- Server may change cookie on each response.
	- Typical usage: cookie includes a handle to server-side iformation
	- That's why some sites don't work if cookies are completely disabled.

4. Framework make all these abstractions convenient for programmers to use, without sweating the details.

5. and helps map SaaS to 3-tier , shared nothing architecure.




__SaaS architecture__


The big picture

View (HTML & CSS, XML & XPath)
Controller (URI's , HTTP, TCP/IP stack, REST & RESTful routes)
Model (Database and migrations, CRUD)















